![[oracle索引结构图.png]]
索引是由Root（根块）、Branch（茎块）和Leaf（叶子块）三部分组成的，其中Leaf（叶子块）主要存储了key column value（索引列具体值），以及能具体定位到数据块所在位置的rowid（注意区分索引块和数据块）



![](https://cdn.nlark.com/yuque/0/2022/png/25651796/1668869776280-83d8fdff-9cfd-483e-93f7-cd77dc2d12b1.png)



### 索引的创建流程

**要建索引先排序**

**列值入块成索引**

**填满一块接一块**

### 索引的特点

**索引树的高度一般都比较低。**

**索引由索引列存储的值及rowid组成。**

**索引本身是有序的**

### 妙用三特征之高度较低

索引的这个高度不高的特性给查询带来了巨大的便利,即时是相差很大数量级的表,在查询单条记录的时候速度几乎一样

**优化案例:**在梁老师的优化工作中，曾经有一个经典的案例，就是通过业务分析，把一个有80多个字段的表精简为20个字段，从而在需要使用全表扫描的场合下大大提升了性能。

**优化案例**:关于分区索引，也有过经典的案例，某表有近百个分区，但是查询中居然用不到分区条件，这样进行索引扫描时等同于扫描100个高度并没有低多少的小索引，结果导致系统运行得非常缓慢，后面梁老师将局部索引改为全局索引后，系统性能马上提升了近百倍。

### 巧用三特征之存储列值

#### COUNT（*）优化

**不加非空条件**

![](https://cdn.nlark.com/yuque/0/2022/png/25651796/1669124379429-61fc5d5d-e04d-4267-9672-ac163faf5c1f.png)

**加非空条件**

![](https://cdn.nlark.com/yuque/0/2022/png/25651796/1669124395636-bc005bdf-cdfa-40a8-9e7f-b3c74db370d7.png)

Oracle设置索引列为非空后，就会用到索引了。执行计划从原先的TABLE ACCESS FULL变化为INDEX FAST FULL SCAN，

#### SUM/AVG优化

此类语句在运算时有无is not null的取值都是等价的查询，而COUNT（*）则不一样，有无is not null 的取值是不等价的！

#### MAX/MIN优化

同上

**案例:**梁老师曾接触过数据达到近百亿条的表，MAX 该表索引列的查询也不过在不到1秒的时间就完成了，如果这个列没有索引，这个统计的查询将是一场噩梦！”

**MAX/MIN的性能陷阱**

select min（object_id）,max（object_id）from t //无法用INDEX FULL SCAN（MIN/MAX）会走全表扫描

优化语句

select max, min from (select max(object_id) max from t1) a, (select min(object_id) min from t1) b;

#### 索引回表与优化

**案例:**我处理过非常多的类似案例，就是明明只需要返回少数字段，但是开发人员为了写 SQL语句方便而写了*。这种情况在开发中非常常见，比如刚才的语句，可能只需查询返回object_id列，但是写成了*。

### 活用三特征之索引有序

#### order by排序优化

索引可以有效避免排序

**distinct排重优化**

distinct 会产生排序.

**UNION合并的优化**

UNION语句需要去重,所以会有排序操作.

**优化案例:**梁老师所经历的众多案例中，最常见的UNION的优化居然是把UNION改为UNION-ALL。在某些业务场景下，两个表根本就不可能有重复，却用UNION而不用UNION-ALL，这时要做的事情就是，将UNION修改为UNION-ALL。”

**优化案例:**电信计费系统每月月初都会出账、销账，涉及大量的表插入操作。速度非常慢，往往需要10多个小时才能完成。这些表的记录和梁老师老师刚才在笔记本电脑的数据库试验环境可是有天壤之别的，不是100多万条而是千万条甚至上亿条，有的表的索引的个数也远不止3个，虽然机器性能非常强劲，但也还是非常缓慢。“后来梁老师建议先将索引失效，等插入完毕后再让索引生效，结果速度有了大幅度提升，出账时插入环节的时间从原先的10多个小时缩减到2小时以内，大大提升了总体的出账速度。

### 位图索引

COUNT（*）的性能，在非空列有BTREE索引的情况下，该索引的性能远高于全表扫描。不过性能最高的是列上有位图索引的情况，比用到普通非空列的BTREE索引时的性能又高出一大截

**位图索引适用场景**

第一，位图索引列大量重复；第二，该表极少更新
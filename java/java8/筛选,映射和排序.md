## 筛选与切片
```java
/**
     * 筛选与切片
     * filter   接收Lambda，从流中排除某些元素
     * limit    截断流，使袁术不超过给定的数量。
     * skip(n)  跳过元素，返回一个扔掉了前n个元素的流。若元素中不足n个，则返回一个空流。与limit(n)互补
     * distinct 筛选，通过流产生的元素的hashCode() 和 equals()去除重复元素
     */
    public static void test2() {
        List<Employee> emps = Arrays.asList(
                new Employee(101, "张三", 18, 9999.99),
                new Employee(102, "李四", 59, 6666.66),
                new Employee(103, "王五", 28, 3333.33),
                new Employee(104, "赵六", 8, 7777.77),
                new Employee(105, "田七", 38, 5555.55)
        );


        Stream<Employee> stream = emps.stream()
                                      .filter(x -> { //中间操作，不会执行任何操作
            System.out.println("Stream API 的中间操作");
            return x.getAge() > 35;
        });

        //终止操作：一次性执行全部内容，即"惰性求值"
        stream.forEach(System.out::println);


    }
```


## 映射
```java
   public static void test5() {
        Arrays.asList("aaa","bbb","ccc").stream()
                                        .map(x -> x.toUpperCase())
                                        .forEach(System.out::println);

        System.out.println("---------------");
        emps.stream()
            .map(Employee::getAge)
//            .map(x -> x*100)
            .forEach(System.out::println);

    }
```

## 排序
```java
 /**
     * sorted  默认排序
     * sorted(Comparator) 定制化排序
     */
    public static void test8() {
        emps.stream().sorted((x,y) -> {
           if(x.getAge() == y.getAge()) {
               return x.getName().compareTo(y.getName());
           } else {
               return Integer.compare(x.getAge(),y.getAge());
           }
        }).forEach(System.out::println);
    }

```



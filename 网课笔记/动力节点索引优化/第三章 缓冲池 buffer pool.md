### 一、内部结构

整个buffer pool是由缓冲页和控制块组成的：

-   **缓冲页：**buffer pool中存放的【数据页】我们称之为【缓冲页】，和磁盘上的数据页是一一对应的，都是16KB，缓冲页的数据，是从磁盘上加载到buffer pool当中的一个完整页。
-   **控制块：**他是缓冲页【描述信息】，这一块区域保存的是数据页所属的表空间号，数据页编号，数据页地址，以及一些链表相关的节点信息等，每个控制块大小是缓存页的5%左右，大约是800个字节。
- ### 二、free链

刚初始化的buffer pool，内存中都是【空白的缓冲页】，但是随着时间的推移，程序在执行过程中会不断的有新的页被缓存起来，那怎么来判断哪些缓冲页是【闲置状态】，可以被使用呢，此时就需要【控制块来进行标记和管理】了。innodb在设计之初，会将所有【空闲的缓冲页】所对应的【控制块】作为一个个的节点，形成一个链表，这个链表就是free链，翻译过来就是空闲链表，如下图![[Pasted image 20221212232328.png]]### 三、flush链表

#### [#](https://www.ydlclass.com/doc21xnv/database/mysqladvance/mysqlAdvance1.html#_1%E3%80%81%E8%84%8F%E9%A1%B5)1、脏页

在sql的执行过程中，无论是增删改查，都是优先在buffer pool中进行的，这样可以极大的保证执行效率。但是同样会有一个问题，假如我们对缓存页的某些数据进行了修改（执行了一条update语句），就会导致buffer pool中的缓冲页和磁盘的数据页【数据不一致】，那么此时的缓冲页就称之为【脏页】。当然，这也就说明了，脏页的数据是要刷到磁盘上的。

我在看极客时间的专栏时，有一位老师的比喻很不错，在古代的酒楼中记账是个技术活，可能经常会有赊账行为。每次记账、赊账都会将相关记录记录在账本之上。但是当饭点高峰期，记账数据巨大，张三仗着自己的岳父是县令大人又来赊账一笔，掌柜一时间太忙没有时间翻阅账本，查看张三的历史记录，所以单独使用一个小黑板，记了一笔张三今天赊账10两银子，一会李四来赊账，再在上面记上一笔。等过了饭点，有时间了，再将记录誊抄至账本，计算张三和李四的总赊账额度，其实就是这么个原理。

#### [#](https://www.ydlclass.com/doc21xnv/database/mysqladvance/mysqlAdvance1.html#_2%E3%80%81%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84)2、链表结构
![[Pasted image 20221212232402.png]]
#### 3、刷盘时机

后台会有专门的线程每隔一段时间就把flush链表中的脏页刷入磁盘中，刷新的速率取决与当前系统是否繁忙。在这样的机制下，万一系统奔溃，是会产生数据不一致的问题的，没有刷入磁盘的数据就会丢失，而mysql通过日志系统解决了这个问题，以后的章节会详细讲解。

### [#](https://www.ydlclass.com/doc21xnv/database/mysqladvance/mysqlAdvance1.html#%E5%9B%9B%E3%80%81lru%E9%93%BE%E8%A1%A8)四、LRU链表
#### 1、概述

内存是有限的，buffer pool更是有限的，缓存只是数据的中转站，当我们的数据量很大以后，buffer pool其实是仅仅能容纳很少一部分数据，所以buffer pool的容量很有可能被使用殆尽，如果此时我们还想继续缓存数据页那该怎么办？

合理的做法就是，当需要更多的空间缓存【新的数据页】的时候，我们将最近使用最少的【缓冲页淘汰掉】就可以了，这就是典型的LRU（Least Recently Used）算法，我们在讲java的时候也手动实现过基于linkedhashmap的LRU算法。对于innodb而言，则是通过【LRU链表】来完成此功能的，他的结构和上边讲的free链表、flush链表基本相同，只是负责的功能不同而已。

于是，一个简单的思路诞生了，当客户端访问一条数据时，会加载对应的数据页到buffer pool，并会将缓冲页对应的控制块放置到【LRU链表的首位】。一旦buffer pool被占满，则从链表的末端开始淘汰数据，这是最简单的实现。

#### [#](https://www.ydlclass.com/doc21xnv/database/mysqladvance/mysqlAdvance1.html#_2%E3%80%81%E4%BC%98%E5%8C%96)2、优化

但是，实际的在使用场景中，我们需要对原有的LRU链表进行优化，因为他在一下场景可能会出现一些问题：

-   数据页预读：我们在讲多线程的时候是讲过【预读性原理】（当一个应用在访问一个数据时，很有可能会继续访问和他相邻的数据），cpu的高级缓冲区读取主存的数据也不是一个字节一个字节的读取，而是一下子会读取一个【缓存行】。同理，innodb从磁盘读取数据，也不一定是一页页读取，当mysql读取当前需要的页时，如果觉得后续操作会使用【附近的页】，就会将他们一起缓存到buffer pool，这样的作用是为了提升效率。但是，这也会导致大量的使用频率并不高的数据放置在LRU链表头部，反而将一些真正的【热点数据】淘汰。
-   全表扫描：一条【select * from user】 语句，会直接将一张表的全表数据缓存，并全部放在LRU链表头部，一样会淘汰很多热点数据。

所以，innodb对该链表进行了优化，将【LRU链表】分成了两个区域，分为【热数据区】和【冷数据区】，默认情况下冷数据区占了总链表的37%，机构如下：![[Pasted image 20221212232440.png]]